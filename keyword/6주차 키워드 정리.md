- ListView
    - ListView란 무엇일까요?
        
        - 스크롤 가능한 리스트 형태의 UI 컴포넌트
        - 여러 개의 view를 세로로 나열해 표시함.
        - 스크롤, 클릭 이벤트를 처리할 수 있음.
        - 코드
        
        ```xml
        <ListView
            android:id="@+id/myListView"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />
        ```
        
        - 재사용성, 성능 측면에서 떨어짐.
        - 최근엔 RecyclerView를 많이 씀.
    - ListView에 들어갈 아이템들은 어떻게 저장해야 할까요?
        
        - ListView에 아이템을 직접 등록하지 않고 아이템 목록을 **`Adapter`를 통해 ListView에 연결**
        - 아이템 리스트 생성 - 어댑터 생성 - 어댑터와 리스트뷰 연결의 3단계로 아이템을 연결.
        - 데이터를 변경하고자 한다면 **Adapter를 새로 생성하거나**, `notifyDataSetChanged()`를 사용해 갱신해야 함.
    - ListView는 어떤 구성요소로 되어있을까요?
        
        |구성 요소|설명|
        |---|---|
        |**ListView**|화면에 스크롤 가능한 리스트 형태로 아이템을 보여주는 뷰. `Adapter`를 통해 데이터를 가져와 각 항목을 View로 렌더링함.|
        |**Adapter**|데이터와 ListView를 연결해주는 역할. 데이터를 받아서 **각 항목 뷰(View)**로 바꿔줌. (`ArrayAdapter`, `BaseAdapter`, `SimpleAdapter` 등)|
        |**데이터 소스**|리스트에 보여줄 실제 데이터. 배열, 리스트, 데이터베이스 결과 등. Adapter가 이 데이터를 읽어와 각 항목을 생성함.|
        |**Row Layout (항목 뷰)**|각 리스트 항목을 어떻게 보여줄지 정의하는 레이아웃 (예: 텍스트, 이미지 포함 등). XML로 커스터마이징 가능.|
        |**ViewHolder (선택적)**|성능 향상을 위한 패턴. `findViewById()` 호출을 줄여 불필요한 리소스를 절약함. 주로 `BaseAdapter` 구현 시 사용됨.|
        |**OnItemClickListener**|사용자가 리스트 항목을 클릭했을 때 동작을 정의할 수 있는 리스너.|
        
- Adapter
    - Android에서 사용되는 Adapter란 무엇일까요?
        - 데이터와 화면(뷰)를 연결해주는 매개
        - `ArrayAdapter`, `BaseAdapter`, `RecyclerView.Adapter` 등이 있음
        - 사용시 장점
            - **코드 재사용성:** 비슷한 형태의 아이템을 여러 번 표시해야 할 때 Adapter를 재사용
            - **관심사 분리:** 데이터 관리 로직과 화면 표시 로직을 분리. 코드를 더 깔끔하고 유지보수하기 쉽게 만듦.
            - **유연성:** 다양한 종류의 데이터를 다양한 형태로 화면에 표시할 수 있도록 유연성을 제공.
            - **효율적인 업데이트:** 특히 `RecyclerView`의 `ViewHolder` 패턴과 함께 사용되면 화면 깜빡임 없이 효율적으로 아이템을 업데이트.
    - Adapter는 주로 어떤 역할을 할까요?
        - **데이터 제공자:** Adapter는 앱의 데이터 소스(예: 배열, 리스트, 데이터베이스 커서 등)로부터 데이터를 가져옴
        - **뷰 생성 및 바인딩:** 가져온 데이터를 기반으로 화면에 표시될 각 아이템에 대한 뷰(View)를 생성하고, 해당 뷰에 데이터를 채워 넣음. (바인딩(Binding))
        - **AdapterView와 함께 사용:** Adapter는 `ListView`, `RecyclerView`, `GridView`, `Spinner`와 같은 `AdapterView` 계열의 뷰와 함께 사용. 이 `AdapterView`들은 Adapter가 제공하는 뷰들을 화면에 효율적으로 보여주는 역할.
    - ListView의 Adapter는 어떤 구성 요소를 가지고 있을까요?
        - **ArrayAdapter:** 간단한 문자열 리스트와 같은 단일 뷰 타입의 데이터를 표시할 때 주로 사용.
        - **BaseAdapter:** Adapter 클래스를 직접 상속받아 다양한 뷰 타입과 복잡한 레이아웃을 처리할 수 있도록 유연성을 제공
        - **CursorAdapter:** 데이터베이스 쿼리 결과인 `Cursor` 객체의 데이터를 `ListView`나 `GridView`에 표시할 때 사용
        - **RecyclerView.Adapter:** 유연하고 효율적인 리스트 표시를 위한 가장 강력한 Adapter로, `ViewHolder` 패턴을 강제하여 뷰 재활용을 최적화. 현대 안드로이드 개발에서 가장 많이 사용되는 Adapter
        - **SimpleCursorAdapter:** `CursorAdapter`를 좀 더 쉽게 사용할 수 있도록 제공되는 클래스.
        - 이 외에도 필요에 따라 직접 Adapter를 상속받아 커스텀 Adapter를 만들 수 있음.
- RecyclerView
    - RecyclerView란 무엇일까요?
        
        - 리스트나 격자 형태의 데이터를 효율적으로 표시하기 위해 만들어진 아주 강력하고 유연한 뷰 그룹
        - **대량의 데이터를 효율적이고 유연하게 표시하기 위한 필수적인 뷰 그룹**
        - 현대 안드로이드 앱 개발에서는 리스트 형태의 UI를 구현할 때 대부분 RecyclerView를 사용
        - 특징
            - **향상된 성능:** `ViewHolder` 패턴과 뷰 재활용 덕분에 `ListView`보다 훨씬 부드러운 스크롤 성능을 제공해요. 특히 데이터 양이 많을 때 그 차이가 확연히 드러납니다.
            - **다양한 레이아웃 지원:** `LayoutManager`를 통해 리스트, 격자, 가로 스크롤 등 다양한 레이아웃을 쉽게 구현할 수 있어요.
            - **쉬운 애니메이션 적용:** `ItemAnimator`를 통해 아이템 변화에 대한 시각적인 효과를 쉽게 추가하여 사용자 경험을 향상시킬 수 있어요.
            - **더 나은 구조:** 관심사가 분리된 구조로 인해 코드의 유지보수성이 높아지고 재사용성이 좋아져요.
    - RecyclerView와 ListView는 어떤 차이점이 있을까요?
        
        - RecyclerView는
            - **ViewHolder 패턴을 기본 내장**
            - **효율적인 View 재사용**으로 메모리 절약
            - 다양한 레이아웃 매니저 지원 (수직, 수평, 그리드 등)
            - 항목 추가/삭제/이동에 **디폴트 애니메이션 지원**
            - **데이터 변경과 UI 업데이트가 분리**되어 효율적
        - 반면 ListView는
            - View 재사용을 개발자가 조정해야 함 (getView() - convertView)
            - ViewHolder 패턴을 수동으로 구현해야 함.
            - 레이아웃 변경이 유연하지 않음.
            - 애니메이션, 다중 뷰 처리에 제약
    - RecyclerView Adapter는 어떤 구성 요소를 가지고 있을까요?
        
        - **RecyclerView:** 아이템 뷰들을 표시하는 컨테이너 역할을 하는 뷰 그룹
        - **Adapter:** 데이터 소스와 RecyclerView 사이를 연결하고, 각 아이템에 대한 뷰를 생성하고 데이터를 바인딩하는 역할
        - **ViewHolder:** 각 아이템 뷰를 담고 있으며, 뷰 내의 하위 뷰들을 캐싱하여 findViewById() 호출을 줄이는 역할을 하는 클래스. Adapter에서 ViewHolder를 생성하고 데이터를 할당.
        - **LayoutManager:** RecyclerView 내의 아이템들을 어떻게 배치할지 결정하는 객체. `LinearLayoutManager`, `GridLayoutManager`, `StaggeredGridLayoutManager` 등이 제공되며, 필요에 따라 커스텀 LayoutManager를 만들 수도 있음.
        - **ItemAnimator:** 아이템의 추가, 삭제, 이동 시 애니메이션 효과를 관리하는 객체 `DefaultItemAnimator`가 기본으로 제공.
        - **ItemDecoration:** RecyclerView의 각 아이템 사이에 구분선이나 간격 등을 추가하는 데 사용되는 클래스
    - RecyclerView를 설정할 때 주의해야 하는 점은 무엇이 있을까요?
        
        - RecyclerView는 `ViewHolder` 패턴을 **필수적으로** 사용
        - `ViewHolder`를 구현하지 않으면 앱이 제대로 동작하지 않거나 심각한 성능 저하를 일으킬 수 있음.
        - **뷰 캐싱:** `ViewHolder` 내부에 아이템 뷰의 하위 뷰들(TextView, ImageView 등)을 멤버 변수로 저장해두어 `onCreateViewHolder()`에서 뷰를 처음 생성할 때 `findViewById()`를 한 번만 호출
        - 가능하다면 데이터 변경 시 기존 객체를 수정하는 대신 새로운 객체를 생성하여 Adapter에 전달하는 것이 예측 가능하고 안정적인 UI 업데이트에 도움
        - 데이터 로딩이나 무거운 연산은 메인 스레드에서 수행하지 않도록 주의
    - ViewPager2 에서 사용했던 FragmentStateAdapter와 RecyclerView.Adapter는 어떤 차이가 있을까요?
        
        |특징|FragmentStateAdapter|RecyclerView.Adapter|
        |---|---|---|
        |**관리 대상**|Fragment|View|
        |**재활용/상태**|Fragment 생명주기/상태 관리|View 재활용 (직접 상태 관리)|
        |**필수 메서드**|`getItemCount()`, `createFragment()`|`getItemCount()`, `onCreateViewHolder()`, `onBindViewHolder()`|
        |**주 사용처**|ViewPager2 (Fragment 페이지)|RecyclerView, ViewPager2 (단순 View 페이지)|
        
- foreground service
    - foreground service란 무엇일까요?
        - 사용자에게 중요한 작업을 수행 중임을 알리고, 시스템에 의해 쉽게 종료되지 않도록 우선순위를 높게 유지하는 서비스
        - 사용자가 인지해야 하고, 앱이 종료되어도 계속 실행되어야 하는 작업에 사용
        - **알림 필수:** 상태 표시줄에 지속적인 알림을 보여줘야 함.
        - **높은 우선순위:** 백그라운드 서비스보다 강제 종료될 가능성이 낮음.
        - **사용자 인지:** 사용자가 서비스 실행을 인지할 수 있음.
    - foreground service를 사용하는 이유는 무엇일까요?
        - **작업 지속성:** 앱이 백그라운드로 가거나 화면이 꺼져도 중단 없이 작업을 계속.
        - **시스템 강제 종료 방지:** 높은 우선순위로 인해 시스템이 메모리 부족 등으로 앱을 강제 종료할 가능성을 줄임.
        - **사용자 인지 및 제어:** 알림을 통해 사용자에게 서비스 실행 상태를 알리고, 필요한 경우 사용자가 직접 중지
    - foreground service 사용 시 주의사항은 무엇이 있을까요?
        - **필수 알림 표시:** 사용자에게 명확하고 지속적인 알림을 제공해야 합니다. 알림 없이는 백그라운드 실행 제한으로 인해 서비스가 중단될 수 있습니다.
        - **최소한의 권한 요청:** 필요한 권한만 요청하고, 과도한 권한 요청은 사용자에게 거부감을 줄 수 있습니다.
        - **배터리 소모 최적화:** 지속적인 실행으로 인한 배터리 소모를 최소화해야 합니다. 불필요한 작업을 줄이고, Wakelock 사용에 주의해야 합니다.
        - **사용자 제어 제공:** 사용자가 서비스를 중지하거나 관리할 수 있는 명확한 방법을 제공해야 합니다 (예: 알림에서의 중지 버튼).
        - **UI 스레드 작업 최소화:** 서비스 내에서 UI 관련 작업을 직접 수행하는 것은 피해야 합니다. 필요한 경우 Handler 등을 사용하여 메인 스레드와 통신해야 합니다.
        - **백그라운드 실행 제한 고려:** Android 버전별 백그라운드 실행 제한 사항을 숙지하고, Foreground Service가 필요한 이유를 명확히 해야 합니다. 불필요한 Foreground Service 사용은 지양해야 합니다.
        - **테스트 및 최적화:** 다양한 환경에서 충분한 테스트를 거쳐 안정적인 동작을 확인하고, 성능 최적화를 해야 합니다.
- background service
    - background service란 무엇일까요?
        - 사용자에게 직접적으로 보이지 않고, 백그라운드에서 작업을 수행하는 서비스
        - **UI 없음:** 화면에 사용자 인터페이스를 제공하지 않습니다.
        - **백그라운드 실행:** 앱이 화면에 없거나 종료된 상태에서도 실행될 수 있습니다.
        - **시스템에 의해 종료될 수 있음:** Foreground Service보다 낮은 우선순위를 가지므로, 시스템 리소스 부족 시 강제 종료될 가능성이 높습니다.
    - background service를 사용하는 이유는 무엇일까요?
        - 사용자가 앱을 직접 사용하지 않는 동안에도 특정 작업을 계속 수행해야 할 필요가 있을 때 사용
        - **지속적인 작업 필요:** 앱 업데이트 확인, 데이터 동기화, 푸시 알림 수신 등 사용자의 직접적인 상호작용 없이 주기적으로 또는 특정 이벤트 발생 시 실행되어야 하는 작업이 있습니다.
        - **사용자 경험 향상:** 백그라운드에서 필요한 작업을 미리 처리해두면 사용자가 앱을 열었을 때 더 빠르고 원활한 경험을 제공할 수 있습니다.
        - **시스템 이벤트 처리:** 부팅 완료, 네트워크 연결 변경 등 시스템 이벤트를 감지하여 특정 작업을 수행할 수 있습니다.
    - background service 사용 시 주의사항은 무엇이 있을까요?
        - **백그라운드 실행 제한:** 최신 안드로이드 버전(특히 Android 8.0 이상)에서는 백그라운드 서비스 실행에 많은 제약이 있습니다. 배터리 최적화, 앱 대기 버킷 등으로 인해 서비스가 예기치 않게 종료될 수 있습니다.
        - **WorkManager 고려:** 간단한 백그라운드 작업이나 지연 가능한 작업의 경우, 백그라운드 서비스 대신 WorkManager를 사용하는 것이 권장됩니다. WorkManager는 시스템이 작업을 최적화하여 실행하도록 도와줍니다.
        - **배터리 소모:** 백그라운드 작업은 배터리 소모를 유발할 수 있습니다. 작업을 효율적으로 관리하고, 불필요한 작업을 최소화해야 합니다.
        - **리소스 사용:** CPU, 네트워크 등 시스템 리소스를 과도하게 사용하지 않도록 주의해야 합니다. 이는 다른 앱의 성능에 영향을 미칠 수 있습니다.
        - **사용자 경험:** 불필요하거나 과도한 백그라운드 작업은 사용자 경험을 저해할 수 있습니다. 사용자가 인지하지 못하는 사이에 많은 데이터를 소모하거나 배터리를 소모하는 것은 피해야 합니다.
        - **명시적 실행:** 가능하다면 사용자의 명시적인 액션에 의해 백그라운드 작업을 시작하는 것이 좋습니다.
        - **테스트:** 다양한 안드로이드 버전 및 기기에서 충분한 테스트를 거쳐 백그라운드 서비스가 예상대로 동작하는지 확인해야 합니다.
        - **Foreground Service 전환 고려:** 사용자에게 중요한 작업을 백그라운드에서 지속해야 하는 경우, 사용자에게 알림을 표시하는 Foreground Service로 전환하는 것을 고려해 볼 수 있습니다.