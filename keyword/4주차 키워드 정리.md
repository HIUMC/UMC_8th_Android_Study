- Thread
    - Thread란 무엇일까요?
        - 프로세스 내에서 실행되는 가장 작은 단위
        - 병렬처리: 하나의 프로그램(프로세스) 안에서 동시에 여러 작업을 수행할 수 있도록 해주는 실행 흐름
        - 자원공유: 같은 프로세스 내에서 메모리(힙, 데이터 영역) 공유
        - 상대적으로 가볍고 빠름
    - Thread를 사용하는 예시는 무엇이 있을까요?
        - **웹 브라우저** (크롬, 파이어폭스) → 페이지 렌더링, 다운로드, 사용자 입력을 동시에 처리
        - **게임 개발** → 그래픽 렌더링, AI 계산, 네트워크 통신을 동시에 수행
        - **채팅 애플리케이션** → 메시지 송수신과 UI 업데이트를 동시에 처리
        - **서버 애플리케이션** → 여러 사용자의 요청을 동시에 처리
- Main Thread와 Worker Thread
    - View Control을 담당하는 Thread는 무엇일까요?
        - Main Thread.
        - 프로그램이 실행될 때 가장 먼저 실행되는 **기본 스레드**.
        - 보통 **UI를 관리**하거나 **주요 로직을 실행**하는 역할.
        - 프로그램이 종료되면 메인 스레드도 종료됨.
        - 응답성이 중요 → 시간이 오래 걸리는 작업을 하면 UI가 멈춤 → 이때 Main Thread가 멈추지 않도록 큰 작업을 Worker Thread에서 처리.
    - Worker Thread는 어떤 작업을 담당할까요?
        - 메인 스레드와 별도로 실행되는 **보조 스레드**.
        - 주로 **시간이 오래 걸리는 작업(네트워크 요청, 데이터 처리, 파일 I/O 등)**을 백그라운드에서 실행.
        - **메인 스레드가 멈추지 않도록 도와줌**.
        - 여러 개의 워커 스레드를 사용할 수 있음 (멀티스레딩)
        - 작업이 끝나면 자동으로 종료됨
- Single Thread와 Multi Thread
    - Single-Thread란 무엇일까요?
        - 하나의 프로세스가 **하나의 스레드만 실행**하는 방식.
        - 예: 전통적인 C 프로그램 (main 함수 하나만 실행되는 구조)
    - Multi-Thread란 무엇일까요?
        - 하나의 프로세스 내에서 **여러 개의 스레드가 동시에 실행**되는 방식.
        - 예: 웹 브라우저(페이지 렌더링, 다운로드, 사용자 입력 처리 등 여러 작업을 동시에 수행)
- 동기와 비동기
    - 동기란 무엇일까요?
        - 처리해야 할 작업을 순차적으로 진행. A 작업이 끝나야 B 작업 시작.
        - 한 작업이 끝날 때까지 기다렸다가 다음 작업을 실행
        - 실행 순서가 보장됨
        - 하나의 작업이 오래 걸리면 전체 흐름이 지연됨
    - 비동기란 무엇일까요?
        - 처리해야 할 작업을 병렬적으로 진행. A 작업과 B 작업 함께 수행 가능.
        - 여러 작업을 동시에 실행할 수 있어 **작업 속도가 빨라짐**
        - 실행 순서가 보장되지 않음 → 관리가 필요
        - 하나의 작업이 오래 걸려도 다른 작업은 계속 실행됨
    - 동기와 비동기 각각의 장단점은 무엇이 있을까요?
        - 동기: 실행 순서가 보장되나 오래 걸리는 한 작업이 있으면 전체 흐름이 지연됨
        - 비동기: 여러 작업 동시에 진행하며 작업 속도가 빠르지만 실행 순서가 보장되지 않음
    - 동기와 비동기를 사용하는 예시에는 무엇이 있을까요?
        - 동기
            - 간단한 계산 작업
            - 데이터베이스 조회 (작은 규모)
            - 프로그램 실행 순서가 중요한 경우
        - 비동기
            - **네트워크 요청** (예: 웹사이트 로딩, API 호출)
            - **파일 입출력** (예: 대용량 파일 읽기/쓰기)
            - **멀티태스킹 필요할 때** (예: 웹서버, UI 응답성 유지)
- Handler
    - Android에서 Handler란 무엇일까요?
        - 스레드 간 메시지 전달 및 실행을 관리하는 도구
        - **메인 스레드(UI 스레드)에서 백그라운드 작업을 실행하고 UI를 업데이트할 때** 사용
        - 역할
            - 백그라운드 작업이 끝난 후 UI를 업데이트하는 역할
            - 스레드 간 메시지를 전달하는 역할
            - 일정 시간이 지난 후 특정 작업을 실행하는 **지연 실행 기능 (`postDelayed()`)** 제공
            - `sendMessage()`를 사용한 메시지 처리
	```kotlin
        public class MainActivity extends AppCompatActivity {
            private TextView textView;
            private Handler handler = new Handler(Looper.getMainLooper());  // 메인 스레드 핸들러
        
            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);
                textView = findViewById(R.id.textView);
        
                // 백그라운드 스레드 실행
                new Thread(() -> {
                    try {
                        Thread.sleep(3000);  // 3초 대기 (예: 네트워크 요청)
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
        
                    // 백그라운드 스레드에서 UI 업데이트 (핸들러 사용)
                    handler.post(() -> textView.setText("3초 후 UI 업데이트"));
                }).start();
            }
        }
	```
        
    - Handler를 사용하는 이유는 무엇일까요?
        - Android 앱은 기본적으로 메인 스레드(UI 스레드)에서 실행됨
        - UI 관련 작업(버튼 클릭, 화면 업데이트 등)은 **메인 스레드에서만** 실행 가능.
        - 하지만, **네트워크 요청, 데이터베이스 작업 등은 시간이 오래 걸리므로 백그라운드 스레드에서 처리해야 함.**
        - **백그라운드 스레드는 직접 UI를 수정할 수 없음!**
        - 그래서 백그라운드 스레드에서 메인 스레드로 데이터를 전달하는 도구가 필요. → 그것이 Handler.
    - Handler의 Message란 무엇일까요?
        - Handler에서 데이터를 전달하는 객체.
        - `Handler`는 기본적으로 **`post()`** 또는 **`postDelayed()`** 메서드를 사용해 UI 업데이트 등의 작업을 수행 가능.
        - **복잡한 데이터 전달**이 필요할 때는 **`Message` 객체**를 사용하는 것이 유용
        - 사용 방법
            - `Message` 객체를 만들어 `Handler`에 전송 (`sendMessage()`)
            - `handleMessage()`에서 수신된 메시지를 처리
    ```kotlin
        public class MainActivity extends AppCompatActivity {
            private TextView textView;
        
            // 핸들러 정의
            private Handler handler = new Handler(Looper.getMainLooper()) {
                @Override
                public void handleMessage(Message msg) {
                    super.handleMessage(msg);
                    textView.setText("메시지 수신 완료! 값: " + msg.what);
                }
            };
        
            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);
                textView = findViewById(R.id.textView);
        
                new Thread(() -> {
                    try {
                        Thread.sleep(3000); // 3초 대기
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
        
                    // 메시지 생성 및 전송
                    Message message = handler.obtainMessage();
                    message.what = 100; // 메시지 식별 값
                    handler.sendMessage(message);
                }).start();
            }
        }
    ```
    - Handler를 사용하는 예시에는 무엇이 있을까요?
        - 주로 **백그라운드 작업 처리 후 UI 업데이트 시** 사용
        - **비동기 작업을 실행한 후 메인(UI) 스레드에서 UI를 변경**해야 하는 경우 많이 활용
        - `HandlerThread`를 사용하면 `Handler`가 백그라운드에서 실행되도록 설정 가능       
- Looper
    - Android에서 Looper란 무엇일까요?
        - 스레드에서 무한 루프를 돌면서 메시지 큐(MessageQueue)에서 메시지를 꺼내 처리하는 역할
        - 특정 스레드가 계속해서 **이벤트를 기다리고 처리할 수 있도록 유지**
        - UI 스레드(메인 스레드)나 백그라운드에서 지속적으로 메시지를 처리할 때 사용
        - 사용 방법: 스레드에 메시지 큐를 생성하고 이를 계속 실행(loop)하도록 함
            1. 스레드가 `Looper.prepare()`를 호출하면 **메시지 큐(MessageQueue)**가 생성됨
            2. `Handler`를 통해 메시지를 큐에 추가함
            3. `Looper.loop()`를 실행하면 스레드가 무한 루프를 돌며 메시지를 처리함
            4. `Handler`가 메시지를 받아 실행 (`handleMessage()`)
    - Looper를 활용하는 예시는 무엇이 있을까요?
        - 안드로이드에서는 `Main Thread (UI Thread)`에 기본적으로 `Looper`가 포함되어 있음
        - **`HandlerThread`는 `Looper`를 자동으로 생성**하여 백그라운드에서 지속적인 작업을 수행
        - `HandlerThread` 없이 직접 `Looper`를 사용하는 백그라운드 스레드 만들 수 있음
        - 특정 작업을 일정 간격으로 실행해야 할 때 `Looper`를 활용한 주기적인 작업 실행
- Coroutine
    - Coroutine이란 무엇일까요?
        - **경량 스레드**처럼 동작하는 **비동기 프로그래밍**을 위한 기능
        - 네트워크 요청, 데이터베이스 작업 등 **시간이 오래 걸리는 작업을 효율적으로 처리**
        - 특징
            - **비동기 실행**: `suspend` 키워드를 사용해 함수 실행을 중단하고 다시 재개할 수 있음
            - **경량성**: 기존 스레드보다 가벼워서 메모리 효율이 좋음
            - **구조화된 동시성**: `CoroutineScope`를 사용해 코루틴의 생명주기를 관리
            - **자동 컨텍스트 전환**: UI 작업과 백그라운드 작업을 쉽게 전환
        - 주요 개념
	        - 코루틴 스코프 (`CoroutineScope`)
		        - 코루틴이 실행되는 **범위(생명주기)**를 정의함
		        - `GlobalScope`, `viewModelScope`, `lifecycleScope` 등이 있음
		    - 코루틴 빌더 (`launch`, `async`)
			    - **코루틴을 시작하는 방법**을 제공
			    - `launch {}` → 반환값 없음, `async {}` → `Deferred<T>` 반환
            - 디스패처 (`Dispatchers`)
	            - **코루틴이 실행될 스레드**를 결정
	            - `Dispatchers.Main`(UI 스레드) / `Dispatchers.IO`(입출력 작업) / `Dispatchers.Default`(CPU 집중 작업)
    - Coroutine은 언제 사용할까요?
        
        - 안드로이드에서 오래 걸리는 작업을 **메인(UI) 스레드를 블로킹하지 않고 처리**할 때 필수
        - 오래 걸리는 작업을 **메인 스레드에서 실행하면 앱이 멈추는 문제(ANR)** 가 발생
        - 네트워크 요청은 오래 걸림. → `Dispatchers.IO`
        - DB 작업(데이터 저장/조회)도 시간이 오래 걸릴 수 있음 → `Dispatchers.IO`
        - Glide/Picasso 같은 라이브러리를 안 쓰고 직접 이미지 로딩하면 오래 걸림 → `Dispatchers.IO`
        - `delay()`를 사용하면 특정 작업을 일정 시간 후 실행 가능 → Thread.sleep()은 스레드를 멈추지만 delay()는 비동기적
        - 주기적으로 서버에서 데이터를 받아와야 하는 경우처럼 주기적인 백그라운드 작업 시 필요
    - Coroutine의 Dispatcher란 무엇일까요?
        - **코루틴이 실행될 스레드**를 결정하는 역할
        - withContext 이용해 코루틴 실행 중 **다른 Dispatcher로 전환할 수 있음**
        ```kotlin
        launch(Dispatchers.Main) {
            val data = withContext(Dispatchers.IO) {
                fetchDataFromNetwork() // 네트워크 작업 (백그라운드)
            }
            textView.text = data // UI 업데이트 (메인)
        }
        ```
    - Dispatcher의 종류에는 무엇이 있을까요?
        - `Dispatchers.Main`(UI 스레드): UI 관련 작업, 사용자 입력 처리 등 메인 스레드에서 처리해야 할 작업 수행. 오래 걸리는 작업(네트워크, DB 요청)을 하면 **ANR(Application Not Responding) 오류 발생 가능**
        - `Dispatchers.IO`(입출력 작업 최적화): 백그라운드 실행. **네트워크, 파일 입출력, DB 작업** (IO 작업)에 사용.
        - `Dispatchers.Default`(CPU 집중 작업 최적화): 백그라운드 실행. **CPU 집중 연산(복잡한 계산, 데이터 처리)** 에 사용.
        - `Dispatchers.Unconfined` (제한 없음): 특정한 디스패처가 필요하지 않을 때 사용. 처음 실행된 **스레드를 그대로 사용**하며, 이후 상황에 따라 스레드가 변경될 수 있음. 잘 안씀.