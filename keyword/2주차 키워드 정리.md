- ## Activity
    
    - Activity란 무엇인가요?
        - Fragment와 같이 안드로이드 앱 UI의 기본/필수 구성 요소
        - 액티비티가 구동, 서로 결합되는 방식은 안드로이드 플랫폼의 앱 모델의 기초적인 부분임
            - SAA(Single Activity Architecture): 하나의 액티비티만 사용하는 아키텍처. 다른 부분들은 프래그먼트를 사용해 메모리 효율을 높였다.
        - Activity LifeCycle callback func
            - onCreate(): 무조건 선언해야 하는 콜백함수. 내부에서 setContentView() — 유저 UI를 위한 레이아웃 정의 함수를 꼭 호출해야 함. 시스템이 액티비티를 만들 때 호출됨. 액티비티의 주요 컴포넌트들을 초기화해야 함.
                - onCreate() 콜백 다음은 무조건 onStart()
            - onStart(): onCreate()가 끝나면 액티비티는 Started state에 진입. 유저에게 보이게 된다. 화면 인터렉션과 포그라운드 서비스를 위한 마지막 준비 작업을 하는 함수.
            - onResume(): 유저 인터렉션 시작 직전까지 수행한다. 이때, 인터렉션하고 있는 현재 액티비티는 액티비티 스택의 최상위에 위치하며 모든 유저 입력을 감지한다. 앱의 코어 로직이 onResume()에 선언된다.
                - onResume() 다음으로 항상 onPause() (— 액티비티를 잠시 멈추고 유저 인터렉션을 핸들링)가 수행된다.
            - onPause(): 액티비티가 포커스를 잃거나 Paused state에 진입했을 때 호출되는 콜백. 액티비티가 onPause()에 진입했다면, 뒤로가기 버튼을 누르거나 제스처를 취했을 때처럼 사용자가 해당 액티비티를 떠나고 있는 상황을 의미하며 액티비티는 곧 Stopped 또는 Resumed state로 진입한다. — 상호작용한 유저가 변경을 원하는 ui로 변경 후 진입.
                - DO NOT: data를 저장하거나 db 함수를 실행하거나 네트워크 요청하기 — Saving/Restoring activity state에서 수행해야 함.
                - 다음으로 onStop()이나 onResume()가 온다.
            - onStop(): 더이상 액티비티가 사용자에게 보이지 않을 때 호출됨. 액티비티가 소멸하거나 기존 액티비티가 Resumed state로 변경되며 Stopped 상태의 액티비티를 덮을 때 발생.
                - 다시 실행된다면 onRestart()로 바뀌고 완전히 종료될 경우 onDestory()로 변경된다.
            - onRestart(): Stopped state의 액티비티가 다시 실행될 경우. stop됐을 당시의 상태를 복원한다.
            - onDestroy(): 액티비티를 종료할 때 호출. 일반적으로 액티비티와 액티비티를 포함하는 프로세스가 점유하고 있던 모든 리소스를 풀어준다.
    - 새로운 Activity를 만들기 위해선 어떻게 해야 할까요?
        1. 새 액티비티 파일 만들기: 코틀린 파일과 xml이 함께 생성된다.
        2. xml에서 UI 구성
        3. manifest 파일에서 액티비티 선언 확인: 예전 버전에서는 직접 추가해야 했지만 최근에는 자동으로 추가되도록 바뀌었다.
    - AppcompatActivity란 무엇인가요?
        - Android 3.0부터 액티비티들은 모두 기본으로 Appbar, ActionBar를 가지고 있다.
        - 특정 버전부터 지원되는 ActionBar를 이전 버전에도 적용할 수 있도록 지원해주는 Activity가 AppcompatActivity.
        - setSupportActionBar API를 사용하여 action item, navigation mode 등을 포함하는 action bar를 지원
        - Theme.AppCompat.DayNight 테마를 사용, AppCompatDelegate.setDefaultNightMode(int) API를 사용하여 다크 모드 지원
        - getDrawerToggleDelegate() API를 사용하여 DrawerLayout과 통합
- ## Activity-Layout 결합
    
    - findViewById
        
        - 리소스 id를 통해 레이아웃에 있는 뷰 객체들 중 일치하는 뷰를 가져오는 메서드.
            
        - 성능 별로
            
        - findViewById 사용법
            
            ```kotlin
            ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->
                        val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
                        v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
                        insets
                    }
            ```
            
    - ViewBinding
        
        - ViewBinding 사용법
            - gradle 추가: 안드로이드 3.6부터 지원됨. 버전마다 추가하는 코드가 다르므로 주의.
                
                ```kotlin
                android {
                    ...
                    buildFeatures {
                        viewBinding = true
                    }
                }
                ```
                
            - 액티비티에서 사용
                
                ```kotlin
                override fun onCreate(savedInstanceState: Bundle?) {
                        super.onCreate(savedInstanceState)
                        // MainActivity의 xml 파일을 객체화해 코드로 사용.
                        val binding = ActivityMainBinding.inflate(layoutInflater)
                        // 기존 xml을 가져와 뷰를 만들던 것을 뷰 계층의 루트로 바꾼다.
                        setContentView(binding.root)
                        
                        binding.name.setText("박정민")
                }
                ```
                
                - 단, 프래그먼트에서는 onDestroyView() 코드를 추가해야 함. — 바인딩되는 뷰의 생명주기보다 프래그먼트 생명주기가 더 길기 때문에 바인딩 클래스의 인스턴스도 함께 정리함.
                    
                    ```kotlin
                    @Override
                        public void onDestroyView() {
                            super.onDestroyView();
                            binding = null;
                        }
                    ```
                    
    - findViewById보다 ViewBinding이 권장되는 이유
        
        - findViewById의 단점
            - 많이 사용할 시 보일러 플레이트 코드 다수 생성
            - Null 안정성: 개발자가 실수로 유효하지 않은 id를 사용하면 null 오류가 발생할 수 있다.
            - Type 안정성: textView의 타입을 imageView라고 잘못 적어서 캐스팅하면 cast exception이 발생할 수 있다.
            - 속도가 상대적으로 느리다.
        - ViewBinding의 장점
            - 사용하기 간단하고 코드가 깔끔
            - 뷰의 개수가 많아져도 관리가 편리
- ## 새로운 Activity를 띄우는 방법
    
    - Intent란 무엇일까요?
        
        - 다른 앱 컴포넌트로부터 액션을 요청받았을 때, 혹은 요청할때 사용하는 메시지 오브젝트
        - 주요 사용 상황
            1. 액티비티를 시작할 때
                
                액티비티는 앱의 하나의 화면을 대표. 새로운 액티비티를 열어야할때 startActivity()로 인텐트를 넘겨준다. 이때, 인텐트는 새 액티비티를 시작하라는 것과 필요한 데이터를 포함한다.
                
                액티비티의 반환을 받고 싶을때는 startActivityForResult()을 호출한다. 반환은 onActivityResult() 콜백함수로 받는다.
                
            2. 서비스를 시작할 때
                
                서비스는 UI 없이 백그라운드에서 수행되는 컴포넌트다. Android 5.0부터는 JobScheduler로 서비스를 시작한다. 서비스가 사용자와 서버간 인터페이스로 설계되었다면 서비스를 다른 컴포넌트와 바인딩할 수 있다. bindService() 함수에 인텐트를 넘겨주면 된다.
                
            3. 브로드캐스트를 전달할 때
                
                브로드캐스트는 어떤 앱이든 받을 수 있는 메시지다. 시스템이 시스템 이벤트로 다양한 브로드캐스트를 전달한다. sendBroadcast() 또는 sendOrderedBroadcast() 함수를 인텐트에 넘겨주면 브로드캐스트를 다른 앱에 전달할 수 있다.
                
    - Intent를 사용하여 Activity 간 데이터를 전달하려면 어떻게 해야할까요?
        
        - putExtra(key, value)를 사용한다.
            
            ```kotlin
            //editText에 입력한 문자열을 얻어 온다.
            String input = editText.getText().toString(); 
            //인텐트 선언 및 정의
            Intent intent = new Intent(MainActivity.this, SubActivity.class);
            //입력한 input값을 intent로 전달한다.
            intent.putExtra("text", input);
            //액티비티 이동
            startActivity(intent);
            ```
            
- ## 명시적 Intent와 암시적 Intent
    
    - 명시적 Intent란 무엇일까요?
        
        - 명시적 인텐트는 실행할 컴포넌트의 이름과 클래스명을 명시적으로 작성하는 방식이다.
            
        - 실행하고자하는 컴포넌트가 명확할 때 사용한다.
            
            ```kotlin
            val yellowStamp = findViewById<ImageView>(R.id.img_yellowStamp)
            yellowStamp.setOnClickListener {
            		// 실행할 컴포넌트 이름 - detailActivity가 명시되어 있다.
            		val intent = Intent(this, DetailActivity::class.java)
                startActivity(intent)
            }
            ```
            
    - 암시적 Intent란 무엇일까요?
        
        - 암시적 인텐트는 명확한 컴포넌트의 이름을 명시하지 않고 어떤 의도만으로도 원하는 컴포넌트를 실행하는 방식이다.
            
        - 인텐트 객체에 의도를 담아 startActivity() 함수를 호출하면 시스템이 해당 의도를 적절하게 처리할 수 있는 컴포넌트를 찾아 처리 결과를 사용자에게 제공한다.
            
        - Action, Category, Type 등을 저장해 시스템에 보낸다.
            
            ```kotlin
            // Create the text message with a string.
            val sendIntent = Intent().apply {
            		// 암시적 인텐트의 동작(의도) 정의
                action = Intent.ACTION_SEND
                putExtra(Intent.EXTRA_TEXT, textMessage)
                type = "text/plain"
            }
            
            // Try to invoke the intent.
            try {
                startActivity(sendIntent)
            } catch (e: ActivityNotFoundException) {
                // Define what your app should do if no activity can handle the intent.
            }
            ```
            
    - 두 Intent를 사용하는 예시에는 각각 무엇이 있을까요?
        
        - 서비스를 시작할 때에는 무조건 명시적 인텐트를 사용해야 한다. 보안 문제로 인해 암시적 인텐트를 사용할 경우 오류가 발생한다.
        - 명시적 인텐트는 주로 앱 내부에서 액티비티나 서비스를 실행할 때 사용한다.
            - 새로운 액티비티를 시작할 때
            - 새로운 서비스를 시작할 때
        - 암시적 인텐트를 주로 다른 앱의 컴포넌트를 실행할 때 사용한다.
            - “텍스트를 전송하기”를 요청하면 시스템이 해당 작업을 처리할 수 있는 앱의 목록을 제공.
- ## Fragment
    
    - Framgent의 정의는 무엇일까요?
        
        - UI의 일부를 나타내는 컴포넌트
    - Fragment를 사용하는 이유는 무엇일까요?
        
        - 화면을 재사용 가능.
        - 동적으로 UI 변경 가능
        - Activity 보다 상대적으로 적은 메모리 리소스 사용
    - 새 Fragment는 어떻게 만들 수 있을까요?
        
        - Fragment
            
            액티비티처럼 프래그먼트 파일을 추가하면 kotlin 파일과 xml 레이아웃 파일이 추가된다.
            
    - Fragment는 어떻게 화면에 보이게 할 수 있을까요?
        
        - 액티비티에 연결해 화면에 보이게 할 수 있다.
        - 액티비티 위에 프래그먼트를 띄울 때에는 FrameLayout을 사용한다.
- ## Bundle
    
    - Bundle은 무엇일까요?
        - 데이터를 저장하고 전달하는 객체.
        - 액티비티, 프래그먼트 간 데이터 전달에 사용된다
        - 화면 회전과 같은 리컴포지션 상황에 데이터를 유지시켜준다.
    - Intent와 Bundle을 결합하는 방법은 무엇일까요?
        - 액티비티-액티비티 사이의 데이터 전달시에 인텐트를 사용한다.
            - 데이터를 보낼 때
                
                ```kotlin
                val intent = Intent(this, SecondActivity::class.java)
                intent.putExtra("username", "chatgpt")
                intent.putExtra("age", 25)
                startActivity(intent)
                ```
                
                - putExtra(key, value)로 데이터가 담긴 번들을 인텐트에 결합한다.
            - 데이터를 받을 때
                
                ```kotlin
                val username = intent.getStringExtra("username")
                val age = intent.getIntExtra("age", 0)
                ```
                
                - get___Extra(key, defaultValue)로 인텐트에서 데이터가 담긴 번들을 가져온다.
        - 액티비티-프래그먼트, 프래그먼트-프래그먼트 사이의 데이터 전달시에는 번들을 사용한다.
            - 데이터를 보낼 때
                
                ```kotlin
                val fragment = ExampleFragment()
                val bundle = Bundle()
                bundle.putString("message", "Hello Fragment!")
                fragment.arguments = bundle
                ```
                
                - 프래그먼트는 인텐트가 사용되는 컴포넌트에 속하지 않으므로 번들을 사용해 데이터를 전달한다.
                - put___(key, value)로 데이터를 번들에 저장한다.
                - 번들을 보낼 fragment의 argument로 번들을 지정한다.
            - 데이터를 받을 때
                
                ```kotlin
                val message = arguments?.getString("message")
                ```
                
                - get___(key) 함수로 arguement에서 데이터를 받아온다.
                - 해당 함수에서는 defaultValue 인자를 지원하지 않는다.
        - 그렇다면 인텐트와 번들을 결합해야 하는 경우엔 무엇이 있을까?
            - 데이터 수가 적을 경우 putExtra() 함수로 인텐트에 직접 데이터를 넣는 것이 효율적.
                
            - 하지만 액티비티와 프래그먼트 모두가 같은 데이터를 받아야 할 때 — 데이터 형식을 번들로 지정하는 것이 효율적.
                
            - 많은 데이터, 복잡한 데이터 구조체를 사용하는 경우, 번들을 사용하는 것이 관리에 용이.
                
                - 번들을 따로 만들어 그룹화하는 것이 쉬움
                - Parcelable, Serializable 객체를 다룰 때 데이터 추가, 변경 등 관리하기 용이
            - 데이터를 보낼 때
                
                ```kotlin
                val intent = Intent(this, SecondActivity::class.java)
                val bundle = Bundle()
                bundle.putString("username", "chatgpt")
                bundle.putInt("age", 25)
                intent.putExtras(bundle) // Bundle을 Intent에 넣음
                startActivity(intent)
                ```
                
            - 데이터를 받을 때
                
                ```kotlin
                val bundle = intent.extras
                val username = bundle?.getString("username")
                val age = bundle?.getInt("age", 0)
                ```
                
- ## FragmentManager
    
    - FragmentManager란 무엇일까요?
        - 프래그먼트를 추가, 제거, 교체하는 역할을 하는 관리자 객체
    - FragmentManager는 언제 사용해야 될까요?
        - 앱에서 프래그먼트를 동적으로 조작하고 싶을 때 사용
        - 역할
            - 프래그먼트 추가, 교체, 제거
            - 백스택 관리
            - 프래그먼트 찾기
- ## BottomNavigationView란?
    
    - BottomNavigationView란 무엇이고, 어떤 기능을 할까요?
        - UI의 하단에 위치하는 바 형태의 네비게이션 버튼 모음.
        - 메뉴 항목에 따라 화면을 전환하는 역할을 함.
        - 전환되는 화면은 주로 fragment로 구성됨.
    - BottomNavigationView가 사용된 예시에는 무엇이 있을까요?
        - 많은 어플리케이션에서 사용되고 있다. 예시는 쿠팡과 네이버 지도다.
            
            ![KakaoTalk_Photo_2025-03-25-20-20-15 004.jpeg](attachment:63b23117-4738-4ffc-83c8-f931abb6db07:KakaoTalk_Photo_2025-03-25-20-20-15_004.jpeg)
            
            ![KakaoTalk_Photo_2025-03-25-20-20-15 003.jpeg](attachment:c0e74908-9bf4-4315-b3dd-098d0207870b:KakaoTalk_Photo_2025-03-25-20-20-15_003.jpeg)
            
- ## BottomNavigationView의 구성 요소
    
    - BottomNavigationView를 사용하려면 레이아웃에 추가를 해야합니다. 이 때 어떤 값들이 필수적으로 지정되어야 할까요?
        
        - BottomNavigationView
        - BottomNavigationView 레이아웃을 위한 xml 파일을 따로 만든다면 Activity에 FrameLayout을 추가한다.
    - Menu 리소스 XML
        
        - <menu> 태그는 무엇일까요?
            
            - 현재 편집하고 있는 리소스가 menu라는 의미.
            - layout의 경우에는 어떤 레이아웃인지 명시한다.
        - <item> 태그는 무엇일까요?
            
            - 하단 네비게이션 바에서 전환될 화면에 대한 바로가기다.
        - <item> 태그에 설정할 수 있는 항목에는 무엇이 있을까요?
            
            - 아이템의 id, 네비게이션 바에 표시될 icon, 네비게이션 바에 표시될 title
            
            ```kotlin
            <item
            		android:id="@+id/navigation_mypage"
                android:icon="@drawable/flowbite_user_outline"
                android:title=""
            />
            ```
            
    - 화면 구성
        
        ![Untitled](attachment:3cf80661-4cea-48b2-b1b8-a432b34028db:Untitled.png)
        
        1. 왼쪽의 예시 화면에서 (A)와 (B)에 해당하는 각각의 알맞은 **화면 구성 요소**를 선택해주세요!
            - (A) = Activity
            - (B) = Fragment
        2. 왼쪽 화면을 구성하기 위해서 일반적으로 몇 개의 Fragment가 필요한가요??
            - 정답 ) 3개
- ## BottomNavigationView 설정하기
    
    - 각 Item을 클릭했을 때 나타나는 이벤트 설정하기 **[필수]**
        
        ```kotlin
        // BottomNavigationView 클릭 이벤트 설정
        binding.bottomNavigationBar.setOnItemSelectedListener { item ->
        	val selectedFragment = when (item.itemId) {
        		R.id.navigation_home -> HomeFragment()
            R.id.navigation_edit -> EditFragment()
        	  R.id.navigation_calendar -> CalendarFragment()
            R.id.navigation_profile -> UserFragment()
            else -> null
        	}
        
          selectedFragment?.let {
            supportFragmentManager.beginTransaction()
              .replace(R.id.fragment_container, it)
              .commit()
          }
        
          true
        }
        ```
        
    - BottomNavigationView의 주요 속성들을 정리해 주세요!
        
        ```kotlin
        <com.google.android.material.bottomnavigation.BottomNavigationView
                android:id="@+id/bottom_navigation_bar" // id
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:labelVisibilityMode="unlabeled" // navigation title 보이지 않게 설정
                app:layout_constraintBottom_toBottomOf="parent"
                app:menu="@menu/bottom_navigation" // 메뉴의 네비게이션 아이템과 연결
                app:itemRippleColor="@null" // 아이템 선택시 잔물결 효과 - 없앰
                app:itemActiveIndicatorStyle="@null" // 활성화된 아이콘 뒤로 둥근 배경 - 없앰
                android:background="@color/white" // 네비게이션 바 색상
                app:itemIconTint="@drawable/navi_icon_color_selector" // 아이콘 색상 - selector를 사용해 활성화/비활성화 색상 설정
                app:itemIconSize="34dp"
                android:elevation="8dp" // shadow를 넣는 속성.. 인데 잘 안보인다
                />
        ```